name: Engine Monitor

on:
  schedule:
    - cron: "*/5 * * * *" # every 5 minutes
  workflow_dispatch:
    inputs:
      backfill:
        description: "Run monitor with ?backfill=true"
        type: boolean
        default: false

jobs:
  monitor:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    concurrency:
      group: monitor-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Call /api/engine/monitor (external-runner mode)
        env:
          MONITOR_URL: ${{ secrets.MONITOR_URL }}
          ENGINE_MONITOR_TOKEN: ${{ secrets.ENGINE_MONITOR_TOKEN }}
          BACKFILL: ${{ github.event.inputs.backfill }}
        run: |
          if [ -z "$MONITOR_URL" ]; then
            echo "MONITOR_URL secret is missing"; exit 1; fi
          URL="$MONITOR_URL"
          if [ "$BACKFILL" = "true" ]; then
            if echo "$URL" | grep -q "?"; then URL="$URL&backfill=true"; else URL="$URL?backfill=true"; fi
          fi
          # Force external-runner mode
          if echo "$URL" | grep -q "?"; then URL="$URL&mode=external"; else URL="$URL?mode=external"; fi
          echo "POST $URL"
          http_code=$(curl -sS -o /tmp/resp.json -w "%{http_code}" -H "Authorization: Bearer $ENGINE_MONITOR_TOKEN" -X POST "$URL")
          echo "Response ($http_code):" && cat /tmp/resp.json || true
          if [ "$http_code" -ge 300 ]; then
            echo "Monitor returned HTTP $http_code"; exit 1; fi

      - name: Run pending runs (Python worker)
        env:
          MONITOR_URL: ${{ secrets.MONITOR_URL }}
          ENGINE_MONITOR_TOKEN: ${{ secrets.ENGINE_MONITOR_TOKEN }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          R2_ENDPOINT_URL: ${{ secrets.R2_ENDPOINT_URL }}
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_BUCKET_NAME: ${{ secrets.R2_BUCKET_NAME }}
          R2_REGION: auto
        run: |
          python -c 'import sys, json; js=json.load(open("/tmp/resp.json"));
          runs=js.get("startedDetails",[]);
          import subprocess;
          for r in runs:
            url=r.get("url"); run_id=str(r.get("runId")); max_items=r.get("maxItems") or 0;
            print("running:", run_id, url, max_items);
            code=subprocess.call(["python","-m","app.cli","--start-url",url,"--max-items",str(max_items),"--run-id",run_id]);
            if code!=0: sys.exit(code)'

      - name: Notify Slack on failure
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            msg=":rotating_light: Monitor failed for $GITHUB_REPOSITORY@$GITHUB_REF â€” run $GITHUB_RUN_ID"
            payload=$(printf '{"text":"%s"}' "$msg")
            curl -X POST -H 'Content-type: application/json' --data "$payload" "$SLACK_WEBHOOK_URL" || true
          else
            echo "SLACK_WEBHOOK_URL not set; skipping Slack notification"
          fi
